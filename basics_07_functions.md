# Функции
> Когда лень писать одно и то же несколько раз

## Что такое функция
> Функция - это именованный блок кода, который можно вызывать для исполнения. Может принимать параметры, может возвращать значение.

Достаточно часто возникает ситуация, когда нужно в коде совершать какие-то однотипные действия. Есть выбор:
1. Копировать код каждый раз, когда нужно вновь выполнить этот алгоритм
1. Создать функцию и вызывать каждый раз ее

Допустим, нам нужно написать программу, которая запрашивает у пользователя 3 числа, а затем выводит произведение этих чисел. Вроде бы ничего сложного. Только вот код:

```c++
#include <iostream>
using namespace std;

int main()
{
    int a, b, c;

    cin >> a >> b >> c;
    cout << "a * b * c = " << a*b*c << endl;

    return 0;
}
```

Работать, конечно, будет, но на "честном слове". На честном слове пользователя, что он введет именно числа, а не попытается ввести какие-то другие символы. А по-хорошему считается, что пользователь - это... Ну как бы повежливее сказать. Обезьяна с гранатой - сделать может что угодно, когда угодно и с чем угодно. Один человек сказал мне вот что:
> Программа должна работать даже если я сяду на клавиатуру задницей.

Чтобы это высказывание работало для такой, казалось бы, простейшей программы, нужно ввести "защиту от дурака" (подробнее об этой теме в отдельной теме), т.е. удостоверится, что пользователь действительно введет числа. Если что-то он делает не так, нужно "ударить его по рукам" и подсказать, как сделать правильно.

Например, как-то так (допустим, функции использовать не будем):
```c++
#include <iostream>
using namespace std;

int main()
{
    int a, b, c;

    do
    {
        int buffLen = 20;
        char* buff = new char[buffLen];

        cout << "Input number: ";
        cin.getline(buff, buffLen);

        bool isOk = true;
        for (int i = 0; i < strlen(buff); i++)
            if (buff[i] < '0' || buff[i] > '9') {
                isOk = false;
                break;
            }

        if (!isOk)
            cout << "Not number. Try again!" << endl;
        else {
            a = atoi(buff);
            break;
        }
    } while (true);

    do
    {
        int buffLen = 20;
        char* buff = new char[buffLen];

        cout << "Input number: ";
        cin.getline(buff, buffLen);

        bool isOk = true;
        for (int i = 0; i < strlen(buff); i++)
            if (buff[i] < '0' || buff[i] > '9') {
                isOk = false;
                break;
            }

        if (!isOk)
            cout << "Not number. Try again!" << endl;
        else {
            b = atoi(buff);
            break;
        }
    } while (true);

    do
    {
        int buffLen = 20;
        char* buff = new char[buffLen];

        cout << "Input number: ";
        cin.getline(buff, buffLen);

        bool isOk = true;
        for (int i = 0; i < strlen(buff); i++)
            if (buff[i] < '0' || buff[i] > '9') {
                isOk = false;
                break;
            }

        if (!isOk)
            cout << "Not number. Try again!" << endl;
        else {
            c = atoi(buff);
            break;
        }
    } while (true);

    cout << endl << "a * b * c = " << a*b*c << endl;

    return 0;
}
```

Какой замечательный код, не правда ли? Такая простая программа превратилась в жирного и неповоротливого монстра. А теперь представьте, что нам нужно изменить текст ошибки. Править это придется 3 раза. А если мы в программе в разных местах должны  считывать числа? Несколько десяткой раз. Представили? Да, морозец по коже, соглашусь.

Поэтому лучше будет все-таки не боятся использовать функции:

```c++
int readNumber()
{

    do
    {
        int buffLen = 20;
        char* buff = new char[buffLen];

        cout << "Input number: ";
        cin.getline(buff, buffLen);

        bool isOk = true;
        for (int i = 0; i < strlen(buff); i++)
            if (buff[i] < '0' || buff[i] > '9') {
                isOk = false;
                break;
            }

        if (!isOk)
            cout << "Not number. Try again!" << endl;
        else 
            return atoi(buff);
    } while (true);
}

int main()
{
    int a = readNumber(), b = readNumber(), c = readNumber();

    cout << endl << "a * b * c = " << a*b*c << endl;

    return 0;
}
```
Так-то лучше!

## Как понять, что нужно создавать функцию
На самом деле это достаточно творческий вопрос. Каждый разработчик сам решает, когда "пора". Но основное правило такое:
> Если в коде есть 2 и более повторяющиеся участка кода, значит, их нужно выносить в отдельную функцию.

Некоторые IDE сами отслеживают повторяющиеся участки кода и начинают назойливо предлагать вынести их в функцию.

Также тревожным сигналом является, если вы копируете больше пары строк для вставки где-то в вашем алгоритме. Это уже "повторяющийся код", которого нужно избегать.

Но опять же все эти советы относительны. В первую очередь нужно оперировать здравым смыслом.

## Синтаксис заголовка функции
```
тип_возвращаемого_значения имя_функции(список_параметров);
// Или более кратко
ТВЗ имя_функции(параметры);
```

## Параметры и возвращаемое значение

## Прототип функции